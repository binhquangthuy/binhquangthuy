pipeline {    agent any    environment {        JAVA_IMAGE = 'FROM openjdk:11'        NODE_IMAGE = 'FROM node:latest'        NGINX_IMAGE = 'FROM nginx:latest'        IP = '10.116.45.188'				IP_ENGINE = '10.116.45.44'        PATH_GRADLE = '/home/recaius/work/gradle-6.8.2/bin/gradle'        PATH_ANGULAR_CLI = '/home/recaius/.npm/bin/ng'        PATH_NPM = '/usr/local/bin/npm'        PATH_IMAGE = '/home/recaius/work/data_config_build/image'        PATH_UPLOAD_IMAGE= '/home/recaius/work/data_config_build/image/uploads'        PATH_JACOCO = '/home/recaius/work/data_config_build/jar-file/jacoco'        PATH_IMAGE_CONTAINER = '/image'        PATH_UPLOAD_IMAGE_CONTAINER = '/image/uploads'        PATH_JACOCO_CONTAINER = '/jacoco'        PATH_COVERAGE_CONTAINER = '/coverage'        SERVICE_ENTRY_API = 'ocr_entry_api'        SERVICE_USER_API = 'user_management_api'        SERVICE_CONTRACT_API = 'contract_management_api'        SERVICE_BATCH_EXECUTION = 'ocr_batch_execution_worker'        SERVICE_ENTRY_WEB_CLIENT = 'ocr_entry_web_client'        SERVICE_ENTRY_DELETION_WORKER = 'ocr_batch_deletion_worker'		SERVICE_OCR_ENGINE_CONTROLLER = 'ocr_engine_controller'        SERVICE_OCR_UTIL = 'ocr_util'        // Config database local        USER_NAME_DB_LOCAL = 'postgres'        PASSWORD_DB_LOCAL = 'postgres'        PORT_DB_LOCAL = '5432'        // Confic database aws        USER_NAME_DB_AWS = 'ocrmaster'        PASSWORD_DB_AWS = '2aaKZKRUKLTa'        PORT_DB_AWS_ENV1 = '50018'        PORT_DB_AWS_ENV4 = '50015'        PORT_DB_AWS_BIG_DATA = '50017'		PORT_DB_AWS_ONPER = '50100'        // Config engine controller        PORT_ENGINE_ENV1 = '50021'        PORT_ENGINE_ENV4 = '50013'        PORT_ENGINE_BIG_DATA = '50014'		// Config engine api        PORT_ENGINE_API_ENV1 = '1307'        PORT_ENGINE_API_ENV4 = '1300'        PORT_ENGINE_API_BIG_DATA = '1309'				PORT_ENGINE_API_LOCAL = '8002'        NAME_DATABASE = 'recaius_ocr'        PATH_CONFIG_SOURCE = '/home/recaius/work/data_config_build'    }    stages {        stage('Build Module') {            steps {                script {                    if (env.SERVICE != null || env.SERVICE != '') {                        if (env.SERVICE == env.SERVICE_ENTRY_WEB_CLIENT) {                            this.processLogicalBuildClient(env.SERVICE)                        } else if (env.SERVICE == env.SERVICE_ENTRY_DELETION_WORKER) {                            this.processLogicalBuilDeletionWorker(env.SERVICE)                        } else if (env.SERVICE == env.SERVICE_OCR_UTIL) {                            this.processLogicalBuilOcrUtil(env.SERVICE)                        }else {                            this.processLogicalBuildServer(env.SERVICE)                        }                        this.processResultBuild()                    }                }            }        }        stage('Result Build') {            steps {                script {                    println readFile(env.PATH_CONFIG_SOURCE + '/result_build')                }            }        }    }}void processLogicalBuildServer(def module) {    image = [env.SERVICE_ENTRY_API, env.SERVICE_BATCH_EXECUTION].contains(module) ? module + ':' + tag(env.BRANCH, env.DATABASE, env.ENGINE) : module + ':' + tag(env.BRANCH, env.DATABASE, '')    container = [env.SERVICE_ENTRY_API, env.SERVICE_BATCH_EXECUTION].contains(module) ? module + '-' + tag(env.BRANCH, env.DATABASE, env.ENGINE) : module + '-' + tag(env.BRANCH, env.DATABASE, '')    // flter container exist by name    def containerId = sh( script: 'docker container ls -q --filter name=' + container, returnStdout: true )    if(containerId != "") {        if ([env.SERVICE_BATCH_EXECUTION].contains(module)) {            image = sh(script: "docker inspect --format=" + "'" + "{{.Config.Image}}" + "'" + " " + containerId, returnStdout: true).trim()            this.stopAndRemoveContainer(containerId)            this.removeImage(image)            this.processLogicalBuildImageAndContainer(container, module, null, image)        } else {            def ports = findPortPrivateDockerByContainerId(containerId)            if(ports != "") {                hostPorts = this.findPortPublicDockerByContainerId(ports, containerId)                image = sh(script: "docker inspect --format=" + "'" + "{{.Config.Image}}" + "'" + " " + containerId, returnStdout: true).trim()                 this.stopAndRemoveContainer(containerId)                this.removeImage(image)                this.processLogicalBuildImageAndContainer(container, module, hostPorts, image)                      }        }    } else {        this.processLogicalBuildImageAndContainer(container, module, this.randomPort(), image)    }}void processLogicalBuildClient(def module) {    image =  module + ':' + tag(env.BRANCH, '', '').replace('-','')    container = module + '-' + tag(env.BRANCH, '', '').replace('-','')    // finter container exist by name    def containerId = sh( script: 'docker container ls -q --filter name=' + container, returnStdout: true )        if(containerId != null && containerId != "") {        def ports = findPortPrivateDockerByContainerId(containerId)        if(ports != "") {            hostPorts = this.findPortPublicDockerByContainerId(ports, containerId)            image = sh(script: "docker inspect --format=" + "'" + "{{.Config.Image}}" + "'" + " " + containerId, returnStdout: true).trim()            this.stopAndRemoveContainer(containerId)            this.removeImage(image)            this.processLogicalBuildImageAndContainer(container, module, hostPorts, image)         }    } else {        this.processLogicalBuildImageAndContainer(container, module, this.randomPort(), image)    }}def appendFile(def fileName, def line) {    def contentAvailable = ""    if (fileExists(fileName)) {        contentAvailable = readFile fileName    }    writeFile file: fileName, text: contentAvailable + "\n" + line}def writeFile(def fileName, def content) {    writeFile file: fileName, text: content}def removeFolderOrFiles(def listPaths) {    listPaths.each { val ->        if (fileExists(val)) {            dir (val) {                deleteDir()            }        }    }  }def tag(def branch, def envDB, def envEng) {    return envEng != '' ? branch.substring(branch.lastIndexOf('/') + 1,  branch.length()) + "-" + envDB + "-" + envEng : branch.substring(branch.lastIndexOf('/') + 1,  branch.length()) + "-" + envDB}def configFileApplication(String module) {    String app = 'src/main/resources/application.properties'    // Config database    if (env.SERVICE_OCR_ENGINE_CONTROLLER != module) {		if(env.DATABASE == 'local') {			appendFile(app, databaseConfig(env.PORT_DB_LOCAL, env.USER_NAME_DB_LOCAL, env.PASSWORD_DB_LOCAL)) 		} else if (env.DATABASE == '1') {			appendFile(app, databaseConfig(env.PORT_DB_AWS_ENV1, env.USER_NAME_DB_AWS, env.PASSWORD_DB_AWS))		} else if (env.DATABASE == '4') {			appendFile(app, databaseConfig(env.PORT_DB_AWS_ENV4, env.USER_NAME_DB_AWS, env.PASSWORD_DB_AWS))		} else if (env.DATABASE == 'Bigdata') {			appendFile(app, databaseConfig(env.PORT_DB_AWS_BIG_DATA, env.USER_NAME_DB_AWS, env.PASSWORD_DB_AWS))		} else if (env.DATABASE == 'Onper') {			appendFile(app, databaseConfig(env.PORT_DB_AWS_ONPER, env.USER_NAME_DB_AWS, env.PASSWORD_DB_AWS))		}	}		// Config engine controller    if(env.SERVICE_ENTRY_API == module || env.SERVICE_BATCH_EXECUTION == module) {        if(env.ENGINE == '1') {            appendFile(app, engineControllerConfig(env.PORT_ENGINE_ENV1, env.SERVICE_ENTRY_API))        } else if (env.ENGINE == '4') {            appendFile(app, engineControllerConfig(env.PORT_ENGINE_ENV4, env.SERVICE_ENTRY_API))        } else if (env.ENGINE == 'Bigdata') {            appendFile(app, engineControllerConfig(env.PORT_ENGINE_BIG_DATA, env.SERVICE_ENTRY_API))        } else if(env.ENGINE == 'local') {			appendFile(app, engineControllerConfig(env.PORT_ENGINE_CONTROLER_LOCAL, env.SERVICE_ENTRY_API))		}    }	if (env.SERVICE_OCR_ENGINE_CONTROLLER == module) {		if (env.ENGINE_API == '1') {			appendFile(app, engineApiConfig(env.PORT_ENGINE_API_ENV1, 1))		} else if (env.ENGINE_API == '4') {			appendFile(app, engineApiConfig(env.PORT_ENGINE_API_ENV4, 1))		} else if (env.ENGINE_API == 'Bigdata') {			appendFile(app, engineApiConfig(env.PORT_ENGINE_API_BIG_DATA, 1))		} else if (env.ENGINE_API == 'local') {			appendFile(app, engineApiConfig(env.PORT_ENGINE, 0))		}	}}def databaseConfig(String port, String user, String password) {    String jdbc = 'spring.datasource.url=jdbc:postgresql://' +  env.IP + ':' + port + '/' + env.NAME_DATABASE     String userName = 'spring.datasource.username=' + user    String passwordUser = 'spring.datasource.password=' + password    return jdbc + '\n' + userName + '\n' + passwordUser}def engineControllerConfig(String port, String service) {    return service == env.SERVICE_BATCH_EXECUTION ? 'ocr_engine.controller.url=http://' +  env.IP + ':' + port + '/ocrengine/' : 'ocr_engine.controller.url=http://' + env.IP + ':' + port + '/'}def engineApiConfig(String port, int i) {	String realtime = '';	String batch = '';		if (i == 0) {	  realtime = 'ocrengine.realtime-endpoint=http://' +  env.IP_ENGINE + ':' + port      batch = 'ocrengine.batch-endpoint=http://' +  env.IP_ENGINE + ':' + port	} else {	  realtime = 'ocrengine.realtime-endpoint=http://' +  env.IP + ':' + port      batch = 'ocrengine.batch-endpoint=http://' +  env.IP + ':' + port	}    return realtime + '\n' + batch}def randomPort() {    if (!fileExists(env.PATH_CONFIG_SOURCE + '/data')) {        sh 'touch data'    }    final max = 60999     def port = Math.abs(new Random().nextInt(max+1))    if(readFile(env.PATH_CONFIG_SOURCE + '/data').readLines().contains(port)) {        return this.randomPort();    }    this.appendFile(env.PATH_CONFIG_SOURCE + '/data', port)    return port}def processLogicalBuildImageAndContainer(def nameContainer, def module, def ports, def nameImage) {    hostPorts = ports    dir (module) {        // Build on module server        if ([env.SERVICE_ENTRY_API, env.SERVICE_USER_API, env.SERVICE_CONTRACT_API, env.SERVICE_BATCH_EXECUTION, env.SERVICE_OCR_ENGINE_CONTROLLER].contains(module)) {            this.buildFileJar(module)            // classes and main just for export coverage            def path = env.PATH_CONFIG_SOURCE + '/' + module + '/data/coverage/' + nameContainer            // Config source need coverage            if([env.SERVICE_ENTRY_API].contains(module)) {                if (!fileExists(path)) {                    sh 'mkdir ' + path                } else {                    sh 'rm -rf ' + path + '/classes/*'                       sh 'rm -rf ' + path + '/main/*'                  }                sh 'cp -a build/classes/. ' + path + '/classes/'                sh 'cp -a src/main/. ' + path + '/main/'            }            this.writeFile('Dockerfile', this.buildDockerFileServer(module))            sh 'docker image build -t ' + nameImage + " ."            if ([env.SERVICE_ENTRY_API, env.SERVICE_USER_API, env.SERVICE_CONTRACT_API, env.SERVICE_OCR_ENGINE_CONTROLLER].contains(module)) {                 sh  'docker run -td --name ' + nameContainer + ' -p ' + ports + ':8080 ' +                     ' -v ' + env.PATH_IMAGE + ':' + env.PATH_IMAGE_CONTAINER +                    ' -v ' + env.PATH_JACOCO + ':' + env.PATH_JACOCO_CONTAINER +                    ' -v ' + env.PATH_UPLOAD_IMAGE + ':' + env.PATH_UPLOAD_IMAGE_CONTAINER +                    ' -v ' + path + ':' + env.PATH_COVERAGE_CONTAINER + ' ' + nameImage             } else if ([env.SERVICE_BATCH_EXECUTION].contains(module)) {                hostPorts = null                sh  'docker run -td --name ' + nameContainer +                     ' -v ' + env.PATH_IMAGE + ':' + env.PATH_IMAGE_CONTAINER +                    ' -v ' + env.PATH_JACOCO + ':' + env.PATH_JACOCO_CONTAINER +                    ' -v ' + env.PATH_UPLOAD_IMAGE + ':' + env.PATH_UPLOAD_IMAGE_CONTAINER +                    ' -v ' + path + ':' + env.PATH_COVERAGE_CONTAINER + ' ' + nameImage            }            if(![env.SERVICE_ENTRY_API].contains(module)) {                sh 'rm -rf ' + env.PATH_CONFIG_SOURCE + '/' + module + '/data/coverage/*'            }        } else if ([env.SERVICE_ENTRY_WEB_CLIENT].contains(module)) {            def listNeedRemove = ['src/assets/config/app.js', 'Dockerfile', 'dist', 'default.conf']            this.removeFolderOrFiles(listNeedRemove)            writeFile('src/assets/config/app.js', this.writeFileApp(env.PORT_ENTRY, env.PORT_USER, env.PORT_CONTRACT))            writeFile('Dockerfile', this.buildDockerFileClient())            sh '$PATH_ANGULAR_CLI build --prod'            if (fileExists('dist')) {                sh 'cp ' + env.PATH_CONFIG_SOURCE + '/' + module + '/default.conf .'                sh 'docker image build -t ' + nameImage + " ."                sh 'docker run -td --name ' + nameContainer + ' -p ' +  ports + ':80' + ' ' + nameImage            }         }        version = sh( script: "git log --oneline -n 5", returnStdout: true ).trim()    } }void buildFileJar(def module) {    def listNeedRemove = ['build', 'build.gradle', 'src/main/resources/application.properties', 'Dockerfile']    this.removeFolderOrFiles(listNeedRemove)    if (module != env.SERVICE_OCR_UTIL) {        sh 'cp ' + env.PATH_CONFIG_SOURCE + '/' + module + '/application.properties src/main/resources/'        this.configFileApplication(module)    }    sh 'cp ' + env.PATH_CONFIG_SOURCE + '/' + module + '/gradle.properties .'    sh 'cp ' + env.PATH_CONFIG_SOURCE + '/' + module + '/build.gradle .'    sh 'rm -rf ../settings.gradle'    sh '$PATH_GRADLE assemble'}def buildDockerFileServer(def module) {    return "$JAVA_IMAGE" + '\n' + "ADD build/libs/" + module + ".jar app.jar" + '\n' + 'ENTRYPOINT ["java","-javaagent:/jacoco/jacocoagent.jar=address=*,port=36320,destfile=jacoco-it.exec,output=tcpserver","-jar","/app.jar"]'}def findPortPrivateDockerByContainerId(def containerId) {    def p = '$p';    def conf = '$conf';    return '"' + sh( script: "docker inspect --format=" + "'" + "{{range $p, $conf := .Config.ExposedPorts}}{{$p}} {{end}}" + "'" + " " + containerId, returnStdout: true ).trim() + '"'}def findPortPublicDockerByContainerId(def portsPrivate, def containerId) {    return sh(script: "docker inspect --format=" + "'" + "{{(index (index .NetworkSettings.Ports " + portsPrivate + ") 0).HostPort}}" + "'" + " " + containerId, returnStdout: true).trim()}void stopAndRemoveContainer(def containerId) {    sh 'docker container stop ' + containerId    sh 'docker container rm ' + containerId}void removeImage(def nameImage) {    sh 'docker image rm ' + nameImage}def writeFileApp(def portEntry, def portUser, def portContract) {    return "CONFIG={\"API_ENDPOINTS\":{\"ENTRY\":\"http://" + env.IP + ':' + portEntry + "/\",\"USER\":\"http://" + env.IP + ':' + portUser + "/\",\"CONTRACT\":\"http://" + env.IP + ':' + portContract + "/\"},\"HASH_ASSETS\":{\"EN\":\"en\",\"JA\":\"ja\"}}"}def buildDockerFileClient() {    return "$NGINX_IMAGE" + '\n' + 'COPY ./dist/entry/ /var/www/html' + '\n' + 'COPY default.conf /etc/nginx/conf.d/default.conf'}void processLogicalBuilDeletionWorker(def module) {    dir(module) {        this.buildFileJar(module)        sh 'cp -a build/libs/module.jar ' + env.PATH_CONFIG_SOURCE + '/jar-file/'    }}void processLogicalBuilOcrUtil(def module) {    dir(module) {        this.buildFileJar(module)        sh 'cp -a build/libs/*.jar ' + env.PATH_CONFIG_SOURCE + '/jar-file/'    }}void processResultBuild() {    dir(env.PATH_CONFIG_SOURCE) {        if (fileExists('result_build')) {            sh 'rm -rf result_build'         }         sh 'touch result_build'        if (![env.SERVICE_OCR_UTIL, env.SERVICE_ENTRY_DELETION_WORKER].contains(env.SERVICE)) {            this.appendFile('result_build', 'Image: ' + image)            this.appendFile('result_build', 'Container: ' + container)            this.appendFile('result_build', 'Port: ' + hostPorts)            this.appendFile('result_build', 'Git commit: ' + version)        } else {            this.appendFile('result_build', 'Position file .jar after build: /home/recaius/work/data_config_build/jar-file/*.jar')        }     } }